#!/usr/bin/env python3
#
# Use this script to download files (outputs, inputs or logs)
# from a Cromwell workflow run on the MacCoss lab
# Cromwell server, m002.grid.gs.washington.edu.
#


import requests
import logging
import datetime
import argparse
# import subprocess
import sys
import os
# import time
import json
import pytz
# import shutil

logging.basicConfig(
    level=logging.INFO, format="%(asctime)s: %(levelname)s: %(message)s"
)
LOGGER = logging.getLogger()


def convert_to_local_time(datetime_str):
    # Convert datetime string to local_tz timezone. This function
    # assumes that the incoming datetime string is using the UTC
    # timezone. This is a good assumption for Cromwell as Cromwell
    # writes all dates in Metadata in UTC by default.
    try:
        local_tz = pytz.timezone('America/Los_Angeles')

        # Create datetime object from string
        dto = datetime.datetime.strptime(datetime_str, "%Y-%m-%dT%H:%M:%S.%fZ")

        # datetime strings generated by Cromwell are always in UTC. Add the
        # timezone to the datetime object
        utc_tz = pytz.timezone('UTC')
        dto_utc = utc_tz.localize(dto)

        # Convert to local_tz
        dto_local = dto_utc.astimezone(local_tz)
    except ValueError:
        # The datetime is in the wrong format. Will use inst["start"] string
        LOGGER.warn(
            "There was a problem converting datetime to local timezone ",
            "The datetime string from the metadata will be used. This ",
            "datetime is in UTC timezone"
        )
        dto_local = datetime_str

    return dto_local


def download_log_file_from_cromwell(
    server, file_path, local_file_path, type, scp_port=22, scp_user=None, scp_key=None
):
    # Download a log file from the cromwell server
    # server: name or ip of the cromwell server
    # file_path: the path on the cromwell server of the file
    #            to be downloaded
    # local_file_path: the path of the copied file on local file system
    # type: how to perform the download. Currently only scp is supported
    # scp_user: user name to be used to authenticate to Cromwell server
    # scp_key: location of ssh key to be used by scp.
    #
    logging.getLogger("paramiko").setLevel(logging.WARNING)
    if type == "scp":
        from scp import SCPClient, SCPException
        from paramiko import SSHClient, AutoAddPolicy

        # Check if ssh private key exists
        expanded_scp_key = os.path.expanduser(scp_key)
        if not os.path.isfile(expanded_scp_key):
            logstatus = (
                "SSH keyfile does not exist '{}'. Download of "
                "log file will be skipped".format(expanded_scp_key)
            )
            # logmsgs = "LOGFILE DOWNLOAD ERROR"
            return logstatus

        ssh = SSHClient()
        # ssh.load_system_host_keys()
        ssh.set_missing_host_key_policy(AutoAddPolicy())
        ssh.connect(
            server, port=scp_port, username=scp_user,
            key_filename=expanded_scp_key, timeout=300
        )

        # Create SCP client
        scp = SCPClient(ssh.get_transport())

        # Download the file
        try:
            # local_file_path = os.path.basename(file_path)
            scp.get(file_path, local_file_path)
            scp.close()
            ssh.close()
        except SCPException as err:
            err.args
            logstatus = (
                "Unable to download log file, '{}': {} ".format(
                    local_file_path, err.args
                )
            )
            # logmsgs = "LOGFILE DOWNLOAD ERROR"
            return logstatus

        logstatus = "True"
        return logstatus
    else:
        # A non-supported download method was selected
        logstatus = (
            "Download method of '{}' was specified and "
            "this is not supported".format(type)
        )
        # logmsgs = "LOGFILE DOWNLOAD ERROR"
        return logstatus


#
# Variables
#
cromwell_server_url = "http://m002.grid.gs.washington.edu:8000"
start_date = "{:%Y%m%d-%H%M%z}".format(datetime.datetime.now())

# Variables for downloading logs from cromwell server
cromwell_server = "m002.grid.gs.washington.edu"
cromwell_scp_port = "22"
cromwell_scp_user = "cromwell-transfer"
cromwell_scp_key = "~/cromwell/.ssh_cromwell_rsa"

# Values for testing locally
cromwell_server = "127.0.0.1"
cromwell_scp_port = "8222"
cromwell_scp_key = "/Users/bconn/.ssh/ssh_cromwell_rsa"
cromwell_server_url = "http://127.0.0.1:8000"

#
# Parse our arguments
#
parser = argparse.ArgumentParser(
    description="Download files from workflow execution on MacCoss"
                " Lab Cromwell Server"
)
parser.add_argument("--id", help="Workflow ID")
parser.add_argument(
    "--type",
    help="Type of files to download. Options are logs, inputs, outputs"
)
parser.add_argument("--call", help="Name of workflow call")
parser.add_argument("--shard", help="Workflow call shard number")

args = parser.parse_args()

# Check for required arguments
if not args.id:
    LOGGER.error(
        "You must specify a workflow ID on the command line. "
        "add the --id option and try again"
    )
    parser.print_usage()
    sys.exit(1)
else:
    workflow_id = args.id

if not args.type:
    # If no type is specified, then the logs will be downloaded
    download_type = "logs"
else:
    if args.type == "logs":
        download_type = "logs"
        LOGGER.info(
            "Workflow Log files (stdout and stderr) will downloaded"
        )
    # elif args.type == "inputs":
    #     download_type = "inputs"
    #     LOGGER.info(
    #         "Workflow input files will downloaded"
    #     )
    elif args.type == "outputs":
        download_type = "outputs"
        LOGGER.info(
            "Workflow output files will downloaded"
        )
    else:
        LOGGER.error(
            "The type of file to download is not valid. "
            "Supported options are logs or outputs"
        )
        sys.exit(1)

if not args.shard:
    shard = "-1"
else:
    shard = args.shard

if not args.call:
    LOGGER.error(
        "You must specify a call name on the command line. "
        "add the --call option and try again"
    )
    parser.print_usage()
    sys.exit(1)
else:
    call_name = args.call

#
# Download metadata for the workflow. Using the metadata we will display
# the status of each task and provide instructions for downloading
# the log files or other outputs.
#
# The first step is to download the metadata. This is a json file
# which contains all information about the workflow run
status_headers = {"accept": "application/json"}
metadata_url = "{}/api/workflows/v1/{}/metadata".format(
    cromwell_server_url, workflow_id
)
try:
    resp = requests.get(metadata_url, headers=status_headers)
    resp.raise_for_status()
except (
    requests.exceptions.HTTPError,
    requests.exceptions.ConnectionError,
    requests.exceptions.Timeout,
    requests.exceptions.RequestException,
) as err:
    LOGGER.error(
        "Download of workflow metadata has failed. "
        "The error was %s. URL of request was %s",
        err,
        metadata_url,
    )
    sys.exit(1)

# Check the status response from the server
if resp.status_code == 200:
    try:
        workflow_metadata = json.loads(resp.text)
    except json.JSONDecodeError as err:
        LOGGER.warn(
            "Download of workflow metadata has failed. "
            "The download request did not return "
            "the proper content %s. URL of request was %s",
            err.msg,
            metadata_url,
        )
        sys.exit(1)
else:
    LOGGER.error(
        "Download of workflow metadata has failed. "
        "Download of metadata request failed with an error code %s. "
        "URL of request was %s. The response from the server: %s",
        resp.status_code,
        metadata_url,
        resp.text,
    )
    sys.exit(1)

# Display a workflow status and general information
print("=================================================")
print("Workflow Name: {}".format(workflow_metadata["workflowName"]))
print("Workflow ID: {}".format(workflow_id))
print("Workflow Status: {}".format(workflow_metadata["status"]))
print("=================================================")
print("")

# Find the call and shard input in the command line
call_exist = False
shard_exist = False
for call in sorted(workflow_metadata["calls"]):
    if call_name == call:
        call_exist = True
        for inst in workflow_metadata["calls"][call]:
            # print("{} = {}".format(shard ,inst["shardIndex"]))
            if int(shard) == inst["shardIndex"]:
                shard_exist = True
                call_metadata = inst
            else:
                continue
        
        if not shard_exist:
            LOGGER.error(
                "Shard %s was not found for Call=%s",
                shard,
                call_name
            )
            LOGGER.error(
                "Run getCromwellWorkflowStatus.py <workflow-id> to "
                "see the Calls and Shards for this workflow."
            )
            print("")
            sys.exit(1)
    else:
        continue

if not call_exist:
    LOGGER.error("ERROR: Call '%s' was not found",call_name)
    LOGGER.error(
                "Run getCromwellWorkflowStatus.py <workflow-id> to "
                "see the Calls and Shards for this workflow."
            )
    print("")
    sys.exit(1)


#
# Download the files for the shard
#
# Download stderr, stdout and background files if they exist
# The background files are the output from cromwell process that
# executes the docker container. This log will show you errors
# when the docker container is not available or has a problem
# starting.
if download_type == "logs":
    print(
        "Download the log files for Shard {} of Call '{}': \n".format(
            shard, call_name
        )
    )

    # Check if this Call/Shard is coming from cache
    # print(call_metadata["callCaching"]["hit"])
    if call_metadata["callCaching"]["hit"] is False:
        stdout_file = call_metadata["stdout"]
        stderr_file = call_metadata["stderr"]
    else:
        print(
            "*** Warning: Output and logs for this call are coming from cache. "
            "stderr-background and stdout-background log files will not be "
            "downloaded ***"
        )
        stdout_file = "{}/cacheCopy/execution/stdout".format(
            call_metadata["callRoot"]
        )
        stderr_file = "{}/cacheCopy/execution/stderr".format(
            call_metadata["callRoot"]
        )

    # Download stderr file
    local_file_path = "{}_{}-{}".format(
        call_name, shard, os.path.basename(stderr_file)
    )
    print(
        "  Download STDERR from {}:{}...".format(
            cromwell_server, stderr_file
        )
    )

    logstatus = download_log_file_from_cromwell(
        cromwell_server,
        stderr_file,
        local_file_path,
        "scp",
        cromwell_scp_port,
        cromwell_scp_user,
        cromwell_scp_key
    )

    if logstatus == "True":
        print("  Downloaded STDERR to ./{}\n".format(local_file_path))
    else:
        print(
            "  ERROR: Log file could not be downloaded. Error was {}\n".format(
                logstatus
            )
        )

    # Download stderr-background file
    if call_metadata["callCaching"]["hit"] is False:
        local_file_path = "{}_{}-{}-background".format(
            call_name, shard, os.path.basename(stderr_file)
        )
        print(
            "  Download STDERR-background for the call "
            "from {}:{}-background... ".format(
                cromwell_server, stderr_file
            )
        )

        logstatus = download_log_file_from_cromwell(
            cromwell_server,
            "{}-background".format(stderr_file),
            local_file_path,
            "scp",
            cromwell_scp_port,
            cromwell_scp_user,
            cromwell_scp_key
        )

        if logstatus == "True":
            print(
                "  Downloaded STDERR-background to ./{} \n".format(
                    local_file_path
                )
            )
        else:
            print(
                "  ERROR: Log could not be downloaded. Error was {}\n".format(
                    logstatus
                )
            )

    # Download stdout file
    local_file_path = "{}_{}-{}".format(
        call_name, shard, os.path.basename(stdout_file)
    )
    print(
        "  Download STDOUT from {}:{}...".format(
            cromwell_server, stdout_file
        )
    )

    logstatus = download_log_file_from_cromwell(
        cromwell_server,
        stdout_file,
        local_file_path,
        "scp",
        cromwell_scp_port,
        cromwell_scp_user,
        cromwell_scp_key
    )

    if logstatus == "True":
        print("  Downloaded STDOUT to ./{}\n".format(local_file_path))
    else:
        print(
            "  ERROR: Log file could not be downloaded. Error was {}\n".format(
                logstatus
            )
        )

    # Download stdout_file-background file
    if call_metadata["callCaching"]["hit"] is False:
        local_file_path = "{}_{}-{}-background".format(
            call_name, shard, os.path.basename(stdout_file)
        )
        print(
            "  Download STDOUT-background for the call "
            "from {}:{}-background... ".format(
                cromwell_server,
                "{}-background".format(stdout_file)
            )
        )

        logstatus = download_log_file_from_cromwell(
            cromwell_server,
            "{}-background".format(stdout_file),
            local_file_path,
            "scp",
            cromwell_scp_port,
            cromwell_scp_user,
            cromwell_scp_key
        )

        if logstatus == "True":
            print(
                "  Downloaded STDOUT-background to ./{} \n".format(
                    local_file_path
                )
            )
        else:
            print(
                "  ERROR: Log could not be downloaded. Error was {}\n".format(
                    logstatus
                )
            )
elif download_type == "outputs":
    # Download any output files
    print(
        "Download the log files for Shard {} of Call '{}': \n".format(
            shard, call_name
        )
    )

    for output in call_metadata["outputs"]:

        local_file_path = "{}_{}-{}-background".format(
            call_name, shard,
            os.path.basename(call_metadata["outputs"][output])
        )

        logstatus = download_log_file_from_cromwell(
            cromwell_server,
            call_metadata["outputs"][output],
            local_file_path,
            "scp",
            cromwell_scp_port,
            cromwell_scp_user,
            cromwell_scp_key
        )

        if logstatus == "True":
            print(
                "  Downloaded {} output to ./{} \n".format(
                    output, local_file_path
                )
            )
        else:
            print(
                "  ERROR: Log could not be downloaded. Error was {}\n".format(
                    logstatus
                )
            )

LOGGER.info(
    "Workflow downloads are complete"
)
# Output the metadata as a JSON file. Use this for testing
# wf_exec_fh = open("./metadata.json", "w")
# wf_exec_fh.write(json.dumps(workflow_metadata, indent=4))
